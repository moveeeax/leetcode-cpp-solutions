# **[Minimize Malware Spread](https://leetcode.com/problems/minimize-malware-spread/description/)**  

## **1Ô∏è‚É£ Problem Understanding**  
### **üìå Intuition**  
The problem focuses on reducing the spread of malware throughout a network represented as a graph using a list of connected nodes. Each node may initially be infected with malware. The goal is to determine which node to remove such that the components of the network are minimized, thereby helping to limit the spread of malware. The output should be the smallest node that achieves this outcome when there are ties.

### **üöÄ Approach**  
1. **Graph Representation**: The network is represented as an undirected graph using an adjacency list.
2. **Connected Components**: For each node, we will find the connected components using Depth-First Search (DFS). While traversing, we will keep track of the number of infected nodes within each component.
3. **Determine Removability**: For each infected node, check if removing it will help reduce the number of total infected nodes in its component (if that component has more than one infected node). If removing multiple infected nodes from the same component does not help, we will choose the smallest node index.
4. **Final Decision**: Among all removable nodes, choose the one with the smallest index.

### **‚è±Ô∏è Complexity Analysis**  
- **Time Complexity**: O(N + E) where N is the number of nodes and E is the number of edges (for graph traversal).  
- **Space Complexity**: O(N + E) for storing the graph and visited nodes.

---  

## **2Ô∏è‚É£ LeetCode Submission**  
```cpp
class MinimizeMalwareSpread {
public:
    int minMalwareSpread(vector<vector<int>>& graph, vector<int>& initial) {
        int n = graph.size();
        vector<bool> visited(n, false);
        vector<int> component(n, -1);
        vector<int> infectedCount(n);
        
        // Sort initial nodes to facilitate finding the smallest index later
        sort(initial.begin(), initial.end());
        
        int componentId = 0;
        unordered_set<int> initialSet(initial.begin(), initial.end());
        
        // Perform DFS to find connected components
        for (int node : initial) {
            if (visited[node]) continue;

            vector<int> stack = {node};
            visited[node] = true;
            int infected = 0;
            vector<int> currentComponent;

            // DFS traversal
            while (!stack.empty()) {
                int curr = stack.back();
                stack.pop_back();
                currentComponent.push_back(curr);
                if (initialSet.count(curr)) infected++;

                for (int neighbor : graph[curr]) {
                    if (!visited[neighbor]) {
                        visited[neighbor] = true;
                        stack.push_back(neighbor);
                    }
                }
            }

            // Assign component ID
            for (int cNode : currentComponent) {
                component[cNode] = componentId;
            }
            infectedCount[componentId] = infected;
            componentId++;
        }

        vector<int> remCount(n, 0);
        int minNode = INT_MAX;
        for (int node : initial) {
            if (infectedCount[component[node]] == 1) {
                remCount[component[node]]++;
            }
        }

        for (int node : initial) {
            int cId = component[node];
            if (infectedCount[cId] == 1) {
                if (remCount[cId] == 1) {
                    minNode = min(minNode, node);
                }
            }
        }

        return minNode == INT_MAX ? *min_element(initial.begin(), initial.end()) : minNode;
    }
};
```  

---  

## **3Ô∏è‚É£ Running Locally**  
### **‚úÖ Steps**  
1. **Create a file**: `minimize_malware_spread.cpp`  
2. **Wrap the `MinimizeMalwareSpread` class** inside `main()`  
3. **Include necessary headers**  
4. **Handle input/output for local execution**  
5. **Compile and run the program**  

---  

## **üìù Full Working Code (Local Execution)**  
```cpp
#include <iostream>
#include <vector>
#include <unordered_set>
#include <algorithm>
#include <climits>
using namespace std;

class MinimizeMalwareSpread {
public:
    int minMalwareSpread(vector<vector<int>>& graph, vector<int>& initial) {
        int n = graph.size();
        vector<bool> visited(n, false);
        vector<int> component(n, -1);
        vector<int> infectedCount(n);
        
        sort(initial.begin(), initial.end());
        int componentId = 0;
        unordered_set<int> initialSet(initial.begin(), initial.end());

        for (int node : initial) {
            if (visited[node]) continue;

            vector<int> stack = {node};
            visited[node] = true;
            int infected = 0;
            vector<int> currentComponent;

            while (!stack.empty()) {
                int curr = stack.back();
                stack.pop_back();
                currentComponent.push_back(curr);
                if (initialSet.count(curr)) infected++;

                for (int neighbor : graph[curr]) {
                    if (!visited[neighbor]) {
                        visited[neighbor] = true;
                        stack.push_back(neighbor);
                    }
                }
            }

            for (int cNode : currentComponent) {
                component[cNode] = componentId;
            }
            infectedCount[componentId] = infected;
            componentId++;
        }

        vector<int> remCount(n, 0);
        int minNode = INT_MAX;
        for (int node : initial) {
            if (infectedCount[component[node]] == 1) {
                remCount[component[node]]++;
            }
        }

        for (int node : initial) {
            int cId = component[node];
            if (infectedCount[cId] == 1) {
                if (remCount[cId] == 1) {
                    minNode = min(minNode, node);
                }
            }
        }

        return minNode == INT_MAX ? *min_element(initial.begin(), initial.end()) : minNode;
    }
};

int main() {
    MinimizeMalwareSpread solution;
    vector<vector<int>> graph = {{1,1,0},{1,1,0},{0,0,1}};
    vector<int> initial = {0,1};
    int result = solution.minMalwareSpread(graph, initial);
    cout << "Output: " << result << endl; // Expected output is 0 or 1 based on inputs
    return 0;
}
```  

---  

## **üîß Compilation & Execution**  
#### **1Ô∏è‚É£ Compile**  
```bash
g++ -std=c++17 minimize_malware_spread.cpp -o minimize_malware_spread
```  

#### **2Ô∏è‚É£ Run**  
```bash
./minimize_malware_spread
```  

---  

## **üéØ Example Run**  
### **Input**  
```
graph = [[1,1,0],[1,1,0],[0,0,1]]
initial = [0,1]
```  
### **Output**  
```
0
```  

---  

## **üìå Summary**  
‚úÖ **Encapsulates LeetCode solution inside `main()`**  
‚úÖ **Handles input/output for local testing**  
‚úÖ **Compiles with `g++ -std=c++17`**  
‚úÖ **Provides structured and formatted execution steps**  

üöÄ **Now you can seamlessly test LeetCode C++ solutions locally!** üöÄ// update on 2025-04-05
// update on 2025-04-22
