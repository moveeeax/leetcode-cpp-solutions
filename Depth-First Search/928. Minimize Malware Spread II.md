# **[Minimize Malware Spread II](https://leetcode.com/problems/minimize-malware-spread-ii/description/)**  

## **1Ô∏è‚É£ Problem Understanding**  
### **üìå Intuition**  
The problem revolves around minimizing the impact of malware spread in a network represented as a graph. Each node indicates a computer, and there is an edge between nodes if the two computers are connected. Given a list of initially infected nodes, the goal is to determine which single node to remove from the network such that the spread of malware is minimized, while also returning the smallest node index in case of a tie.

### **üöÄ Approach**  
1. **Graph Representation**: Represent the network using an adjacency list to easily traverse connected nodes.  
2. **DFS/BFS for Connected Components**: Use Depth-First Search (DFS) or Breadth-First Search (BFS) to identify all connected components of non-infected computers.
3. **Count Infected Nodes**: For each connected component, count the number of initially infected nodes.
4. **Identify Best Node to Remove**: Iterate through the initially infected nodes, for each node:
   - Check the number of connected components it influences.
   - Keep track of the node that helps in minimizing the resultant infection and with the lowest index in case of ties.
5. **Return the Result**: Return the index of the node to be removed.

### **‚è±Ô∏è Complexity Analysis**  
- **Time Complexity**: O(N + M), where N is the number of nodes and M is the number of edges (connections).  
- **Space Complexity**: O(N), for storing the graph in an adjacency list.

---  

## **2Ô∏è‚É£ LeetCode Submission**  
```cpp
class MinimizeMalwareSpreadII {
public:
    int minMalwareSpread(vector<vector<int>>& graph, vector<int>& initial) {
        int n = graph.size();
        vector<bool> infected(n, false);
        for (int node : initial) {
            infected[node] = true;
        }

        vector<vector<int>> components;
        vector<int> componentSize(n);
        vector<int> infectedCount(n, 0);

        // DFS to find components
        vector<bool> visited(n, false);
        for (int i = 0; i < n; ++i) {
            if (!visited[i]) {
                vector<int> currentComponent;
                dfs(graph, visited, currentComponent, i);
                components.push_back(currentComponent);
                for (int node : currentComponent) {
                    componentSize[node] = currentComponent.size();
                }
            }
        }

        // Count infected nodes in components
        for (int node : initial) {
            for (int neighbor : graph[node]) {
                if (!infected[neighbor] && componentSize[node] > 0) {
                    infectedCount[neighbor]++;
                }
            }
        }

        int bestNode = -1, maxSaved = 0;
        for (int node : initial) {
            int savedByRemovingNode = 0;
            for (int neighbor : graph[node]) {
                if (!infected[neighbor]) {
                    savedByRemovingNode += (infectedCount[neighbor] == 1);
                }
            }

            if (savedByRemovingNode > maxSaved || (savedByRemovingNode == maxSaved && (bestNode == -1 || node < bestNode))) {
                maxSaved = savedByRemovingNode;
                bestNode = node;
            }
        }

        return bestNode;
    }

    void dfs(vector<vector<int>>& graph, vector<bool>& visited, vector<int>& currentComponent, int node) {
        visited[node] = true;
        currentComponent.push_back(node);
        for (int neighbor : graph[node]) {
            if (!visited[neighbor]) {
                dfs(graph, visited, currentComponent, neighbor);
            }
        }
    }
};  
```  

---  

## **3Ô∏è‚É£ Running Locally**  
### **‚úÖ Steps**  
1. **Create a file**: `minimize_malware_spread_ii.cpp`  
2. **Wrap the `MinimizeMalwareSpreadII` class** inside `main()`  
3. **Include necessary headers**  
4. **Handle input/output for local execution**  
5. **Compile and run the program**  

---  

## **üìù Full Working Code (Local Execution)**  
```cpp
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

class MinimizeMalwareSpreadII {
public:
    int minMalwareSpread(vector<vector<int>>& graph, vector<int>& initial) {
        int n = graph.size();
        vector<bool> infected(n, false);
        for (int node : initial) {
            infected[node] = true;
        }

        vector<vector<int>> components;
        vector<int> componentSize(n);
        vector<int> infectedCount(n, 0);

        // DFS to find components
        vector<bool> visited(n, false);
        for (int i = 0; i < n; ++i) {
            if (!visited[i]) {
                vector<int> currentComponent;
                dfs(graph, visited, currentComponent, i);
                components.push_back(currentComponent);
                for (int node : currentComponent) {
                    componentSize[node] = currentComponent.size();
                }
            }
        }

        // Count infected nodes in components
        for (int node : initial) {
            for (int neighbor : graph[node]) {
                if (!infected[neighbor] && componentSize[node] > 0) {
                    infectedCount[neighbor]++;
                }
            }
        }

        int bestNode = -1, maxSaved = 0;
        for (int node : initial) {
            int savedByRemovingNode = 0;
            for (int neighbor : graph[node]) {
                if (!infected[neighbor]) {
                    savedByRemovingNode += (infectedCount[neighbor] == 1);
                }
            }

            if (savedByRemovingNode > maxSaved || (savedByRemovingNode == maxSaved && (bestNode == -1 || node < bestNode))) {
                maxSaved = savedByRemovingNode;
                bestNode = node;
            }
        }

        return bestNode;
    }

    void dfs(vector<vector<int>>& graph, vector<bool>& visited, vector<int>& currentComponent, int node) {
        visited[node] = true;
        currentComponent.push_back(node);
        for (int neighbor : graph[node]) {
            if (!visited[neighbor]) {
                dfs(graph, visited, currentComponent, neighbor);
            }
        }
    }
};

int main() {
    MinimizeMalwareSpreadII solution;
    vector<vector<int>> graph = {{1, 1, 0}, {1, 1, 0}, {0, 0, 1}};
    vector<int> initial = {0, 1};
    int result = solution.minMalwareSpread(graph, initial);
    cout << "The node to remove: " << result << endl;
    return 0;
}
```  

---  

## **üîß Compilation & Execution**  
#### **1Ô∏è‚É£ Compile**  
```bash
g++ -std=c++17 minimize_malware_spread_ii.cpp -o minimize_malware_spread_ii
```  

#### **2Ô∏è‚É£ Run**  
```bash
./minimize_malware_spread_ii
```  

---  

## **üéØ Example Run**  
### **Input**  
```
graph = [[1,1,0],[1,1,0],[0,0,1]], initial = [0,1]
```  
### **Output**  
```
The node to remove: 0
```  

---  

## **üìå Summary**  
‚úÖ **Encapsulates LeetCode solution inside `main()`**  
‚úÖ **Handles input/output for local testing**  
‚úÖ **Compiles with `g++ -std=c++17`**  
‚úÖ **Provides structured and formatted execution steps**  

üöÄ **Now you can seamlessly test LeetCode C++ solutions locally!** üöÄ// update on 2020-12-27
// update on 2021-01-09
